diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..869f5e2
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,31 @@
+{
+    "configurations": [
+        {
+            "name": "C/C++: gcc.exe build and debug active file",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",
+            "args": [],
+            "stopAtEntry": false,
+            "cwd": "${fileDirname}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "miDebuggerPath": "E:\\Software\\MinGW\\bin\\gdb.exe",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                },
+                {
+                    "description": "Set Disassembly Flavor to Intel",
+                    "text": "-gdb-set disassembly-flavor intel",
+                    "ignoreFailures": true
+                }
+            ],
+            "preLaunchTask": "C/C++: gcc.exe build active file"
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..bbb8222
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,8 @@
+{
+    "files.associations": {
+        "user.h": "c",
+        "defs.h": "c",
+        "spinlock.h": "c",
+        "fcntl.h": "c"
+    }
+}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..e235530
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,25 @@
+{
+    "tasks": [
+        {
+            "type": "cppbuild",
+            "label": "C/C++: gcc.exe build active file",
+            "command": "E:\\Software\\MinGW\\bin\\gcc.exe",
+            "args": [
+                "-fdiagnostics-color=always",
+                "-g",
+                "${file}",
+                "-o",
+                "${fileDirname}\\${fileBasenameNoExtension}.exe"
+            ],
+            "options": {
+                "cwd": "${fileDirname}"
+            },
+            "problemMatcher": [
+                "$gcc"
+            ],
+            "group": "build",
+            "detail": "Task generated by Debugger."
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/2005006.patch b/2005006.patch
new file mode 100644
index 0000000..e69de29
diff --git a/Makefile b/Makefile
index 62fd0f8..c4dae69 100644
--- a/Makefile
+++ b/Makefile
@@ -139,6 +139,8 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_trace\
+	$U/_load\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/proc.c b/kernel/proc.c
index 58a8a0b..61566a8 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -125,6 +125,7 @@ found:
   p->pid = allocpid();
   p->state = USED;
 
+  p->traced_syscall = 0;
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
@@ -236,7 +237,6 @@ userinit(void)
 
   p = allocproc();
   initproc = p;
-  
   // allocate one user page and copy initcode's instructions
   // and data into it.
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
@@ -322,6 +322,8 @@ fork(void)
   np->state = RUNNABLE;
   release(&np->lock);
 
+  np->traced_syscall = p->traced_syscall;
+
   return pid;
 }
 
@@ -377,6 +379,7 @@ exit(int status)
 
   p->xstate = status;
   p->state = ZOMBIE;
+  p->traced_syscall = 0;
 
   release(&wait_lock);
 
@@ -686,3 +689,4 @@ procdump(void)
     printf("\n");
   }
 }
+
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..a93bde7 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -104,4 +104,15 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int traced_syscall;          // System call number
 };
+
+// Stores the aggregated information of currently running processes
+struct procInfo {
+  int activeProcess;  // # of processes in RUNNABLE and RUNNING state
+  int totalProcess;   // # of total possible processes
+  int memSize;        // summation of memory of all active processes in bytes
+  int totalMemSize;   // all available physical memory in bytes
+};
+
+extern struct proc proc[NPROC];  // The process table
\ No newline at end of file
diff --git a/kernel/spinlock.h b/kernel/spinlock.h
index 4392820..f8c92cc 100644
--- a/kernel/spinlock.h
+++ b/kernel/spinlock.h
@@ -6,4 +6,3 @@ struct spinlock {
   char *name;        // Name of lock.
   struct cpu *cpu;   // The cpu holding the lock.
 };
-
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..dd4115d 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,10 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void);
+extern uint64 sys_info(void);
+extern uint64 sys_getLastCommand(void);
+extern uint64 sys_setLastCommand(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +130,38 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_trace]   sys_trace,
+[SYS_info]    sys_info,
+[SYS_getLastCommand]  sys_getLastCommand,
+[SYS_setLastCommand]  sys_setLastCommand,
+};
+
+char* syscall_names[] = {
+[SYS_fork]    "fork",
+[SYS_exit]    "exit",
+[SYS_wait]    "wait",
+[SYS_pipe]    "pipe",
+[SYS_read]    "read",
+[SYS_kill]    "kill",
+[SYS_exec]    "exec",
+[SYS_fstat]   "fstat",
+[SYS_chdir]   "chdir",
+[SYS_dup]     "dup",
+[SYS_getpid]  "getpid",
+[SYS_sbrk]    "sbrk",
+[SYS_sleep]   "sleep",
+[SYS_uptime]  "uptime",
+[SYS_open]    "open",
+[SYS_write]   "write",
+[SYS_mknod]   "mknod",
+[SYS_unlink]  "unlink",
+[SYS_link]    "link",
+[SYS_mkdir]   "mkdir",
+[SYS_close]   "close",
+[SYS_trace]   "trace",  
+[SYS_info]    "info",
+[SYS_getLastCommand]  "getLastCommand",
+[SYS_setLastCommand]  "setLastCommand",
 };
 
 void
@@ -133,13 +169,206 @@ syscall(void)
 {
   int num;
   struct proc *p = myproc();
-
+  int traced_syscall = p->traced_syscall;
+  // p->traced_syscall = -1;
   num = p->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
-    p->trapframe->a0 = syscalls[num]();
-  } else {
+    
+    if(traced_syscall != num){
+      p->trapframe->a0 = syscalls[num]();
+    }
+    else{
+      printf("pid: %d, syscall: %s, ",p->pid, syscall_names[num]);
+
+      switch(num){
+        case SYS_fork:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_exit:{
+          int status;
+          argint(0, &status);
+          printf("args: (%d), ",status);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_wait:{
+          uint64 addr;
+          argaddr(0, &addr);
+          printf("args: (%lu), ",addr);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_pipe:{
+          uint64 fdarray;
+          argaddr(0, &fdarray);
+          printf("args: (%lu), ",fdarray);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_read:{
+          int fd;
+          uint64 buf;
+          int n;
+          argint(0, &fd);
+          argaddr(1, &buf);
+          argint(2, &n);
+          printf("args: (%d, 0x%p, %d), ",fd, (void*)buf, n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_kill:{
+          int pid;
+          argint(0, &pid);
+          printf("args: (%d), ", pid);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_exec:{
+          char path[MAXPATH];
+          uint64 argv;
+          argstr(0, path, MAXPATH);
+          argaddr(1, &argv);
+          printf("args: (%s, 0x%p), ", path, (void*)argv);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_fstat:{
+          int fd;
+          uint64 statbuf;
+          argint(0, &fd);
+          argaddr(1, &statbuf);
+          printf("args: (%d, 0x%p), ", fd, (void*)statbuf);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_chdir:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_dup:{
+          int oldfd;
+          argint(0, &oldfd);
+          printf("args: (%d), ", oldfd);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_getpid:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_sbrk:{
+          int n;
+          argint(0, &n);
+          printf("args: (%d), ", n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_sleep:{
+          int ticks;
+          argint(0, &ticks);
+          printf("args: (%d), ", ticks);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_uptime:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_open:{
+          char path[MAXPATH];
+          int flag;
+          argstr(0, path, MAXPATH);
+          argint(1, &flag);
+          printf("args: (%s, %d), ", path, flag);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_write:{
+          int fd;
+          uint64 buf;
+          int n;
+          argint(0, &fd);
+          argaddr(1, &buf);
+          argint(2, &n);
+          printf("args: (%d, 0x%p, %d), ", fd, (void*)buf, n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_mknod:{
+          char path[MAXPATH];
+          int major, minor;
+          argstr(0, path, MAXPATH);
+          argint(1, &major);
+          argint(2, &minor);
+          printf("args: (%s, %d, %d), ", path, major, minor);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_unlink:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_link:{
+          char oldpath[MAXPATH];
+          char newpath[MAXPATH];
+          argstr(0, oldpath, MAXPATH);
+          argstr(1, newpath, MAXPATH);
+          printf("args: (%s, %s), ", oldpath, newpath);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_mkdir:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_close:{
+          int fd;
+          argint(0, &fd);
+          printf("args: (%d), ", fd);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        default:{
+          printf("Not a valid syscall\n");
+          break;
+        }
+      }
+    }
+  } 
+  else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
     p->trapframe->a0 = -1;
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..87356e9 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,7 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22
+#define SYS_info   23
+#define SYS_getLastCommand 24
+#define SYS_setLastCommand 25
\ No newline at end of file
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..fd95998 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -6,6 +6,9 @@
 #include "spinlock.h"
 #include "proc.h"
 
+struct spinlock lastCommandLock;
+void initlock(struct spinlock*, char*);
+
 uint64
 sys_exit(void)
 {
@@ -91,3 +94,102 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_trace(void){
+  int syscall_no;
+  argint(0, &syscall_no);
+  if(syscall_no <= 0){
+    return -1;
+  }
+  // printf("Syscall number: %d\n",syscall_no);
+  struct proc* p = myproc(); //get the process which is calling the syscall
+  p->traced_syscall = syscall_no; 
+  return 0; 
+}
+
+uint64 
+sys_info(void){
+  struct procInfo currentInfo;
+  uint64 addr;
+  argaddr(0, &addr);
+  
+  acquire(&proc->lock);
+  currentInfo.activeProcess = 0;
+  currentInfo.totalProcess = NPROC;
+  currentInfo.memSize = 0;
+
+  for(int i=0;i<NPROC;i++){
+    if(proc[i].state == RUNNABLE || proc[i].state == RUNNING || proc[i].state == SLEEPING){
+      currentInfo.activeProcess++;
+      currentInfo.memSize += proc[i].sz;
+    }
+  }
+  currentInfo.totalMemSize = PHYSTOP - KERNBASE;
+  release(&proc->lock);
+
+  return copyout(myproc()->pagetable, addr, (char *)&currentInfo, sizeof(struct procInfo));
+}
+
+static char lastCommands[100][100];
+static int nCommands = 0;
+int getSize(char* str){
+  int i = 0;
+  while(str[i] != '\0'){
+    i++;
+  }
+  return i+1;
+}
+
+void my_strcpy(char* src, char* dst){
+  int i = 0;
+  while(dst[i] != '\0'){
+    dst[i] = '\0';
+    i++;
+  }
+
+  i = 0;
+  while(src[i] != '\0'){
+    dst[i] = src[i];
+    i++;
+  }
+  dst[i] = '\0';
+}
+
+uint64
+sys_getLastCommand(void){
+  initlock(&lastCommandLock, "lastCommandLock");
+  uint64 addr;
+  acquire(&lastCommandLock);
+  argaddr(0, &addr);
+  int n;
+  argint(1, &n);
+  if(n <= 0 || n > nCommands){
+    release(&lastCommandLock);
+    return -1;
+  }
+  struct proc* p = myproc();
+  if(lastCommands[nCommands-n][0] != '\0'){
+    int success = copyout(p->pagetable, addr, lastCommands[nCommands-n], getSize(lastCommands[nCommands-n]));
+    release(&lastCommandLock);
+    return success;
+  }
+  release(&lastCommandLock);
+  return -1;
+}
+
+uint64
+sys_setLastCommand(void){
+  char command[100];
+  uint64 addr;
+  acquire(&lastCommandLock);
+  argaddr(0, &addr);
+  struct proc* p = myproc();
+  if(copyin(p->pagetable, command, addr, 100) < 0){
+    release(&lastCommandLock);
+    return -1;
+  }
+  my_strcpy(command, lastCommands[nCommands++]);
+  release(&lastCommandLock);
+  return 0;
+}
diff --git a/user/load.c b/user/load.c
new file mode 100644
index 0000000..a4bec38
--- /dev/null
+++ b/user/load.c
@@ -0,0 +1,75 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int getFractionPart(int dividend, int divisor){
+    int modified_quotient = (dividend*100)/divisor;
+    int fraction = modified_quotient % 100;
+    return fraction;
+}
+
+int main(int argc, char** argv){
+    if(argc != 3){
+        printf("Wrong number of arguments!\n");
+        printf("Usage: load <child_count> <allocation_amount>\n");
+        exit(1);
+    }
+
+    int childCount = atoi(argv[1]);
+    int allocationAmount = atoi(argv[2]);
+
+    printf("Child count: %d\n", childCount);
+    printf("Allocation amount: %d\n", allocationAmount);
+
+    printf("Parent going to sleep.\n");
+    sleep(10);
+
+    for(int i=0;i<childCount;i++){
+        int pid = fork();
+        //pid == 0 means child process
+        if(pid == 0){
+            sleep(i+1); // Child sleeps for a while
+            printf("Child is created.\n");
+            malloc(allocationAmount);
+            printf("Child allocated memory %d byte.\n", allocationAmount);
+            printf("Child is going to sleep.\n");
+            sleep(100); // Child sleeps for a long time
+            exit(0);
+        }
+    }
+
+    sleep(100);
+
+    printf("Parent wake up.\n");
+    struct procInfo currentInfo;
+    
+    info(&currentInfo);
+    printf("Current system information:\n");
+    printf("Processes: %d/%d\n", currentInfo.activeProcess, currentInfo.totalProcess);
+    int memSize = currentInfo.memSize;
+    int totalMemSize = currentInfo.totalMemSize;
+    int memSize_whole = memSize/(1024*1024);
+    int memSize_fraction = getFractionPart(memSize, 1024*1024);
+    int totalMemSize_whole = totalMemSize/(1024*1024);
+    int totalMemSize_fraction = getFractionPart(totalMemSize, 1024*1024);
+    if(memSize_fraction == 0){
+        printf("RAM: %d/", memSize_whole);
+    }
+    else if(memSize_fraction < 10){
+        printf("RAM: %d.0%d/", memSize_whole, memSize_fraction);
+    }
+    else{
+        printf("RAM: %d.%d/", memSize_whole, memSize_fraction);
+    }
+
+    if(totalMemSize_fraction == 0){
+        printf("%d", totalMemSize_whole);
+    }
+    else if(totalMemSize_fraction < 10){
+        printf("%d.0%d", totalMemSize_whole, totalMemSize_fraction);
+    }
+    else{
+        printf("%d.%d", totalMemSize_whole, totalMemSize_fraction);
+    }
+    printf(" (in MB)\n");
+    return 0;
+}
\ No newline at end of file
diff --git a/user/sh.c b/user/sh.c
index 836ebcb..c86d334 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -159,12 +159,39 @@ main(void)
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      //storing the current command
+      if(setLastCommand(buf) < 0){
+        fprintf(2, "setLastCommand failed\n");
+        continue;
+      }
       // Chdir must be called by the parent, not the child.
       buf[strlen(buf)-1] = 0;  // chop \n
       if(chdir(buf+3) < 0)
         fprintf(2, "cannot cd %s\n", buf+3);
+      
       continue;
     }
+    if(buf[0] == '!' && buf[1] == '!'){
+      int success;
+      if(buf[2] == '\n' || buf[2] == ' '){
+        success = getLastCommand(buf,1);
+      }
+      else{
+        int n = buf[2] - 48;
+        success = getLastCommand(buf,n);
+      }
+      if(success < 0){
+        fprintf(2,"getLastCommand failed\n");
+        continue;
+      }
+      printf("%s",buf);
+    }
+    
+    if(setLastCommand(buf) < 0){
+      fprintf(2, "setLastCommand failed\n");
+      continue;
+    }
+    
     if(fork1() == 0)
       runcmd(parsecmd(buf));
     wait(0);
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..8e21fcd
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,21 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char** argv){
+    int syscall_no;
+    if(argc >= 2){
+        syscall_no = atoi(argv[1]);
+    }
+    else{
+        printf("Please provide a syscall number\n");
+        exit(1);
+    }
+    int valid_syscall = trace(syscall_no);
+    if(valid_syscall == -1){
+        printf("Invalid syscall number\n");
+        exit(1);
+    }
+    // argv+2 reprsents the array from the 3rd to the last element of the argv array 
+    exec(argv[2], argv+2);
+    return 0;
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 04013ca..ea94119 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,11 @@
 struct stat;
-
+// Stores the aggregated information of currently running processes
+struct procInfo{
+    int activeProcess;  // # of processes in RUNNABLE and RUNNING state
+    int totalProcess;   // # of total possible processes
+    int memSize;        // summation of memory of all active processes in bytes
+    int totalMemSize;   // all available physical memory in bytes
+};
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -22,6 +28,10 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);
+int info(struct procInfo*);
+int getLastCommand(char*,int);
+int setLastCommand(char*);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..bbdc987 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,7 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("info");
+entry("getLastCommand");
+entry("setLastCommand");
