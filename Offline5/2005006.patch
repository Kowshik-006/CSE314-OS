diff --git a/.vscode/launch.json b/.vscode/launch.json
new file mode 100644
index 0000000..869f5e2
--- /dev/null
+++ b/.vscode/launch.json
@@ -0,0 +1,31 @@
+{
+    "configurations": [
+        {
+            "name": "C/C++: gcc.exe build and debug active file",
+            "type": "cppdbg",
+            "request": "launch",
+            "program": "${fileDirname}\\${fileBasenameNoExtension}.exe",
+            "args": [],
+            "stopAtEntry": false,
+            "cwd": "${fileDirname}",
+            "environment": [],
+            "externalConsole": false,
+            "MIMode": "gdb",
+            "miDebuggerPath": "E:\\Software\\MinGW\\bin\\gdb.exe",
+            "setupCommands": [
+                {
+                    "description": "Enable pretty-printing for gdb",
+                    "text": "-enable-pretty-printing",
+                    "ignoreFailures": true
+                },
+                {
+                    "description": "Set Disassembly Flavor to Intel",
+                    "text": "-gdb-set disassembly-flavor intel",
+                    "ignoreFailures": true
+                }
+            ],
+            "preLaunchTask": "C/C++: gcc.exe build active file"
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/.vscode/settings.json b/.vscode/settings.json
new file mode 100644
index 0000000..7dc439a
--- /dev/null
+++ b/.vscode/settings.json
@@ -0,0 +1,9 @@
+{
+    "files.associations": {
+        "user.h": "c",
+        "defs.h": "c",
+        "spinlock.h": "c",
+        "fcntl.h": "c"
+    },
+    "makefile.configureOnOpen": false
+}
\ No newline at end of file
diff --git a/.vscode/tasks.json b/.vscode/tasks.json
new file mode 100644
index 0000000..e235530
--- /dev/null
+++ b/.vscode/tasks.json
@@ -0,0 +1,25 @@
+{
+    "tasks": [
+        {
+            "type": "cppbuild",
+            "label": "C/C++: gcc.exe build active file",
+            "command": "E:\\Software\\MinGW\\bin\\gcc.exe",
+            "args": [
+                "-fdiagnostics-color=always",
+                "-g",
+                "${file}",
+                "-o",
+                "${fileDirname}\\${fileBasenameNoExtension}.exe"
+            ],
+            "options": {
+                "cwd": "${fileDirname}"
+            },
+            "problemMatcher": [
+                "$gcc"
+            ],
+            "group": "build",
+            "detail": "Task generated by Debugger."
+        }
+    ],
+    "version": "2.0.0"
+}
\ No newline at end of file
diff --git a/2005006.patch b/2005006.patch
new file mode 100644
index 0000000..e69de29
diff --git a/Makefile b/Makefile
index 62fd0f8..ee39583 100644
--- a/Makefile
+++ b/Makefile
@@ -56,7 +56,7 @@ LD = $(TOOLPREFIX)ld
 OBJCOPY = $(TOOLPREFIX)objcopy
 OBJDUMP = $(TOOLPREFIX)objdump
 
-CFLAGS = -Wall -Werror -O -fno-omit-frame-pointer -ggdb -gdwarf-2
+CFLAGS = -Wall -Werror -Og -fno-omit-frame-pointer -ggdb -gdwarf-2 -g3
 CFLAGS += -MD
 CFLAGS += -mcmodel=medany
 # CFLAGS += -ffreestanding -fno-common -nostdlib -mno-relax
@@ -139,6 +139,14 @@ UPROGS=\
 	$U/_grind\
 	$U/_wc\
 	$U/_zombie\
+	$U/_trace\
+	$U/_load\
+	$U/_seed\
+	$U/_next\
+	$U/_logs\
+	$U/_dummyproc\
+	$U/_testprocinfo\
+	$U/_threads\
 
 fs.img: mkfs/mkfs README $(UPROGS)
 	mkfs/mkfs fs.img README $(UPROGS)
diff --git a/kernel/defs.h b/kernel/defs.h
index d1b6bb9..19a76e2 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -85,10 +85,12 @@ void            printfinit(void);
 int             cpuid(void);
 void            exit(int);
 int             fork(void);
+int             thread_create(uint64,uint64,uint64);
 int             growproc(int);
 void            proc_mapstacks(pagetable_t);
 pagetable_t     proc_pagetable(struct proc *);
 void            proc_freepagetable(pagetable_t, uint64);
+void            thread_freepagetable(pagetable_t, uint64);
 int             kill(int);
 int             killed(struct proc*);
 void            setkilled(struct proc*);
@@ -101,6 +103,7 @@ void            sched(void);
 void            sleep(void*, struct spinlock*);
 void            userinit(void);
 int             wait(uint64);
+int             thread_join(int);
 void            wakeup(void*);
 void            yield(void);
 int             either_copyout(int user_dst, uint64 dst, void *src, uint64 len);
@@ -164,8 +167,12 @@ pagetable_t     uvmcreate(void);
 void            uvmfirst(pagetable_t, uchar *, uint);
 uint64          uvmalloc(pagetable_t, uint64, uint64, int);
 uint64          uvmdealloc(pagetable_t, uint64, uint64);
+uint64          uvmdealloc_mirror(pagetable_t, uint64, uint64);
 int             uvmcopy(pagetable_t, pagetable_t, uint64);
+int             uvmmirror(pagetable_t, pagetable_t, uint64);
+int             uvmmirror_partial(pagetable_t, pagetable_t, uint64, uint64);
 void            uvmfree(pagetable_t, uint64);
+void            uvmfree_thread(pagetable_t, uint64);
 void            uvmunmap(pagetable_t, uint64, uint64, int);
 void            uvmclear(pagetable_t, uint64);
 pte_t *         walk(pagetable_t, uint64, int);
diff --git a/kernel/param.h b/kernel/param.h
index 6624bff..55a1e09 100644
--- a/kernel/param.h
+++ b/kernel/param.h
@@ -11,3 +11,12 @@
 #define NBUF         (MAXOPBLOCKS*3)  // size of disk block cache
 #define FSSIZE       2000  // size of file system in blocks
 #define MAXPATH      128   // maximum file path name
+#define TIME_LIMIT_0 2 // 2 clock ticks for queue 0
+#define TIME_LIMIT_1 4 // 4 clock ticks for queue 1
+#define WAIT_THRES   6 // time after which a process is moved to queue 0 from queue 1
+#define DEFAULT_TICKETS 10 // default number of tickets for a process 
+#define TIME_LIMIT_0 2 // 2 clock ticks for queue 0
+#define TIME_LIMIT_1 4 // 4 clock ticks for queue 1
+#define WAIT_THRES 6 // time after which a process is moved to queue 0 from queue 1
+#define DEFAULT_TICKETS 10 // default number of tickets for a process
+
diff --git a/kernel/proc.c b/kernel/proc.c
index 58a8a0b..6a49b08 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -19,6 +19,7 @@ extern void forkret(void);
 static void freeproc(struct proc *p);
 
 extern char trampoline[]; // trampoline.S
+extern int print_logs; //sysproc.c
 
 // helps ensure that wakeups of wait()ing
 // parents are not lost. helps obey the
@@ -53,6 +54,7 @@ procinit(void)
   initlock(&wait_lock, "wait_lock");
   for(p = proc; p < &proc[NPROC]; p++) {
       initlock(&p->lock, "proc");
+      initlock(&p->memlock, "memlock");
       p->state = UNUSED;
       p->kstack = KSTACK((int) (p - proc));
   }
@@ -124,7 +126,18 @@ allocproc(void)
 found:
   p->pid = allocpid();
   p->state = USED;
-
+  p->original_tickets = DEFAULT_TICKETS;
+  p->current_tickets = DEFAULT_TICKETS;
+  p->runtime = 0;
+  p->ticksQ0 = 0;
+  p->ticksQ1 = 0;
+  p->inQ = 0;
+  p->times_scheduled = 0;
+  p->waiting_time = 0;
+  p->traced_syscall = 0;
+  p->is_thread = 0;
+  p->mem_id = p->pid;
+  // initlock(&p->memlock, "memlock");
   // Allocate a trapframe page.
   if((p->trapframe = (struct trapframe *)kalloc()) == 0){
     freeproc(p);
@@ -158,8 +171,14 @@ freeproc(struct proc *p)
   if(p->trapframe)
     kfree((void*)p->trapframe);
   p->trapframe = 0;
-  if(p->pagetable)
-    proc_freepagetable(p->pagetable, p->sz);
+  // Will not delete the pagetable if it is a thread
+  if(p->pagetable){
+    // Physical memory shall be freed only for processes, not threads
+    if(p->is_thread)
+      thread_freepagetable(p->pagetable, p->sz);
+    else
+      proc_freepagetable(p->pagetable, p->sz);
+  }
   p->pagetable = 0;
   p->sz = 0;
   p->pid = 0;
@@ -214,6 +233,17 @@ proc_freepagetable(pagetable_t pagetable, uint64 sz)
   uvmunmap(pagetable, TRAPFRAME, 1, 0);
   uvmfree(pagetable, sz);
 }
+// Free a thread's page table
+// On clear the mapping, not the physical memory
+void
+thread_freepagetable(pagetable_t pagetable, uint64 sz)
+{
+  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
+  uvmunmap(pagetable, TRAPFRAME, 1, 0);
+  // This function sets the do_free flag in uvmunmap to 0
+  // Which means that the physical memory will not be freed
+  uvmfree_thread(pagetable, sz);
+}
 
 // a user program that calls exec("/init")
 // assembled from ../user/initcode.S
@@ -236,7 +266,6 @@ userinit(void)
 
   p = allocproc();
   initproc = p;
-  
   // allocate one user page and copy initcode's instructions
   // and data into it.
   uvmfirst(p->pagetable, initcode, sizeof(initcode));
@@ -261,16 +290,49 @@ growproc(int n)
 {
   uint64 sz;
   struct proc *p = myproc();
-
+  struct proc *p_i;
+  acquire(&p->memlock);
   sz = p->sz;
   if(n > 0){
+    uint64 oldsz = sz;
     if((sz = uvmalloc(p->pagetable, sz, sz + n, PTE_W)) == 0) {
+      release(&p->memlock);
       return -1;
     }
+
+    // Update the pagetables of the processes with the same memory ID
+    for(p_i= proc; p_i < &proc[NPROC]; p_i++){
+      acquire(&p_i->lock);
+      if(p_i != p && p_i->mem_id == p->mem_id){
+        // sz is the new size now
+        if(uvmmirror_partial(p->pagetable, p_i->pagetable, oldsz, sz) < 0){
+          release(&p_i->lock);
+          release(&p->memlock);
+          return -1;
+        }
+        p_i->sz = sz;
+      }
+      release(&p_i->lock);
+    }
+
   } else if(n < 0){
+    uint64 oldsz = sz;
     sz = uvmdealloc(p->pagetable, sz, sz + n);
+    // If the value of sz does not change, then the deallocation failed
+    if(sz != oldsz){
+      // Update the pagetables of the processes with the same memory ID
+      for(p_i=proc; p_i < &proc[NPROC]; p_i++){
+        acquire(&p_i->lock);
+        if(p_i != p && p_i->mem_id == p->mem_id){
+          // sz is the new size now
+          p_i->sz = uvmdealloc_mirror(p->pagetable, oldsz, sz);
+        }
+        release(&p_i->lock);
+      }
+    }
   }
   p->sz = sz;
+  release(&p->memlock);
   return 0;
 }
 
@@ -322,6 +384,77 @@ fork(void)
   np->state = RUNNABLE;
   release(&np->lock);
 
+  np->traced_syscall = p->traced_syscall;
+  np->original_tickets = p->original_tickets;
+  np->current_tickets = p->original_tickets;
+
+  return pid;
+}
+
+int
+thread_create(uint64 func_addr,uint64 arg_addr,uint64 stack_addr)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p = myproc();
+
+  // Allocate process.
+  if((np = allocproc()) == 0){
+    return -1;
+  }
+  // Setting the thread flag before mirroring
+  // Else, if the uvmmirror fails, the freeproc will clear the physical memory
+  // Which might cause the parent process to lose its memory
+  np->is_thread = 1;
+
+  // Copy user memory from parent to child.
+  if(uvmmirror(p->pagetable, np->pagetable, p->sz) < 0){
+    freeproc(np);
+    release(&np->lock);
+    return -1;
+  }
+  np->sz = p->sz;
+
+  // copy saved user registers.
+  *(np->trapframe) = *(p->trapframe);
+
+  // New stack for the new thread
+  // The stack grows downwards
+  np->trapframe->sp = stack_addr + PGSIZE;
+  // The starting point of the new thread is routine function
+  np->trapframe->epc = func_addr;
+  // Argument for the routine function of the thread
+  np->trapframe->a0 = arg_addr;
+  // Fake return address for the routine function of the thread
+  np->trapframe->ra= 0xffffffff;
+
+  // Thread will share the address space with the parent
+  np->mem_id = p->mem_id;
+  // Threads will share their parent's memlock
+  np->memlock = p->memlock;
+  // Setting the new variables before setting the state to RUNNABLE is necessary
+  // Else the new process will go to the scheduler before the variables are set
+
+  // increment reference counts on open file descriptors.
+  for(i = 0; i < NOFILE; i++)
+    if(p->ofile[i])
+      np->ofile[i] = filedup(p->ofile[i]);
+  np->cwd = idup(p->cwd);
+
+  safestrcpy(np->name, p->name, sizeof(p->name));
+
+  pid = np->pid;
+
+  release(&np->lock);
+
+  acquire(&wait_lock);
+  np->parent = p;
+  release(&wait_lock);
+
+  acquire(&np->lock);
+  np->state = RUNNABLE;
+  release(&np->lock);
+
   return pid;
 }
 
@@ -377,6 +510,7 @@ exit(int status)
 
   p->xstate = status;
   p->state = ZOMBIE;
+  p->traced_syscall = 0;
 
   release(&wait_lock);
 
@@ -434,6 +568,47 @@ wait(uint64 addr)
   }
 }
 
+int
+thread_join(int thread_id)
+{
+  struct proc *pp;
+  int havekids, pid;
+  struct proc *p = myproc();
+
+  acquire(&wait_lock);
+
+  for(;;){
+    // Scan through table looking for exited children.
+    havekids = 0;
+    for(pp = proc; pp < &proc[NPROC]; pp++){
+      if(pp->parent == p){
+        // make sure the child isn't still in exit() or swtch().
+        acquire(&pp->lock);
+
+        havekids = 1;
+        if(pp->state == ZOMBIE && pp->is_thread == 1 && pp->pid == thread_id){
+          // Found one.
+          pid = pp->pid;
+          freeproc(pp);
+          release(&pp->lock);
+          release(&wait_lock);
+          return pid;
+        }
+        release(&pp->lock);
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || killed(p)){
+      release(&wait_lock);
+      return -1;
+    }
+    
+    // Wait for a child to exit.
+    sleep(p, &wait_lock);  //DOC: wait-sleep
+  }
+}
+
 // Per-CPU process scheduler.
 // Each CPU calls scheduler() after setting itself up.
 // Scheduler never returns.  It loops, doing:
@@ -441,6 +616,34 @@ wait(uint64 addr)
 //  - swtch to start running that process.
 //  - eventually that process transfers control
 //    via swtch back to the scheduler.
+
+int rand(int seed){
+  seed ^= seed << 13;
+  seed ^= seed >> 17;
+  seed ^= seed << 5;
+  return seed;
+}
+int getRandomNumber(int n,int seed){
+  // Random number in the range (0,n]
+  return (rand(seed) % n)+1; 
+}
+
+void update_waiting_time(int index){
+  for(int i=0;i<NPROC;i++){
+    if(proc[i].state == RUNNABLE && i != index){
+      acquire(&(proc[i].lock));
+      proc[i].waiting_time++;
+      if(proc[i].inQ == 1 && proc[i].waiting_time >= WAIT_THRES){
+        proc[i].inQ = 0;
+        if(print_logs)
+          printf("BOOST: Process %d (sh) waited for %d ticks, promoted to queue 0\n",proc[i].pid,proc[i].waiting_time);
+        proc[i].waiting_time = 0;
+      }
+      release(&(proc[i].lock));
+    }
+  }
+}
+
 void
 scheduler(void)
 {
@@ -454,22 +657,143 @@ scheduler(void)
     // processes are waiting.
     intr_on();
 
+
+    // Reset the number of tickets for all processes if all RUNNABLE processes have 0 tickets
+    int totalTickets = 0;
     for(p = proc; p < &proc[NPROC]; p++) {
       acquire(&p->lock);
-      if(p->state == RUNNABLE) {
-        // Switch to chosen process.  It is the process's job
-        // to release its lock and then reacquire it
-        // before jumping back to us.
-        p->state = RUNNING;
-        c->proc = p;
-        swtch(&c->context, &p->context);
-
-        // Process is done running for now.
-        // It should have changed its p->state before coming back.
-        c->proc = 0;
+      if(p->state == RUNNABLE){
+        totalTickets += p->current_tickets;
       }
       release(&p->lock);
     }
+    if(totalTickets == 0){
+      for(p = proc; p < &proc[NPROC]; p++) {
+        acquire(&p->lock);
+        p->current_tickets = p->original_tickets;
+        release(&p->lock);
+      }
+    }
+
+    // for(int i=0;i<NPROC;i++){
+    //   acquire(&(proc[i].lock));
+    //   if(proc[i].state == RUNNABLE && proc[i].inQ== 1 && proc[i].waiting_time >= WAIT_THRES){
+    //     proc[i].inQ = 0;
+    //     if(print_logs)
+    //       printf("BOOST: Process %d (sh) waited for %d ticks, promoted to queue 0\n",proc[i].pid,proc[i].waiting_time);
+    //     proc[i].waiting_time = 0;
+    //   }
+    //   release(&(proc[i].lock));
+    // }
+
+
+    //Lottery Scheduling
+    while(1){
+      int indices[NPROC];
+      for(int i = 0;i<NPROC;i++){
+        indices[i] = -1;
+      }
+      int found = 0;
+      for(int i=0;i<NPROC;i++){
+        acquire(&(proc[i].lock));
+        if(proc[i].state == RUNNABLE && proc[i].inQ == 0 && proc[i].current_tickets > 0){
+          indices[i] = i;
+          found = 1;
+        }
+        release(&(proc[i].lock));
+      }
+      if(!found) break;
+
+      int ticketCount = 0;
+      for(int i=0;i<NPROC;i++){
+        if(indices[i] != -1){
+          acquire(&(proc[i].lock));
+          ticketCount += proc[i].current_tickets;
+          release(&(proc[i].lock));
+        }
+      }
+      int seed = 563;
+      int rand_num = getRandomNumber(ticketCount,seed);
+      int index = -1;
+      int sum = 0;
+      for(int i=0;i<NPROC;i++){
+        if(indices[i] != -1){
+          acquire(&(proc[i].lock));
+          sum += proc[i].current_tickets;
+          if(sum >= rand_num){
+            index = i;
+            sum = 0;
+            release(&(proc[i].lock));
+            break;
+          }
+          release(&(proc[i].lock));
+        }
+      }
+
+      if(index != -1){
+        acquire(&(proc[index].lock));
+        if(proc[index].state == RUNNABLE && proc[index].inQ == 0){
+          proc[index].waiting_time = 0;
+          if(print_logs)
+            printf("LOTTERY: Process %d (sh) won in queue 0 with tickets %d\n",proc[index].pid,proc[index].current_tickets);
+          while(proc[index].state == RUNNABLE && proc[index].runtime < TIME_LIMIT_0){
+            proc[index].state = RUNNING;
+            c->proc = &proc[index];
+            swtch(&c->context, &(proc[index].context));
+            proc[index].runtime++;
+            update_waiting_time(index);
+            c->proc = 0;
+          }
+          // if(proc[index].state == RUNNABLE){
+          //   proc[index].inQ = 1;
+          //   if(print_logs)
+          //     printf("DEMO: Process %d (sh) ran for %d time ticks, demoted to queue 1\n",proc[index].pid,proc[index].runtime);
+            
+          // }
+          proc[index].times_scheduled++;
+          proc[index].current_tickets--;
+          proc[index].ticksQ0 += proc[index].runtime;
+          if(proc[index].runtime == TIME_LIMIT_0){
+            proc[index].inQ = 1;
+            if(print_logs)
+              printf("DEMO: Process %d (sh) ran for %d time ticks, demoted to queue 1\n",proc[index].pid,proc[index].runtime);
+            proc[index].runtime = 0;
+          }
+        }
+        release(&(proc[index].lock));
+      }
+    }
+
+    for(int i = 0; i< NPROC; i++) {
+      acquire(&(proc[i].lock)); 
+      // Round Robin for queue 1
+      if(proc[i].state == RUNNABLE && proc[i].inQ == 1) {
+          proc[i].waiting_time = 0;
+          while(proc[i].state == RUNNABLE && proc[i].runtime < TIME_LIMIT_1 ){
+            // Switch to chosen process.  It is the process's job
+            // to release its lock and then reacquire it
+            // before jumping back to us.
+            proc[i].state = RUNNING;
+            c->proc = &proc[i];
+            swtch(&c->context, &(proc[i].context));
+            proc[i].runtime++;
+            update_waiting_time(i);
+            // Process is done running for now.
+            // It should have changed its p->state before coming back.
+            c->proc = 0;
+          }
+          proc[i].times_scheduled++;
+          proc[i].ticksQ1 += proc[i].runtime;
+          if(proc[i].runtime < TIME_LIMIT_1){
+            proc[i].inQ = 0;
+            if(print_logs)
+              printf("PROMO: Process %d (sh) ran for %d time ticks, promoted to queue 0\n",proc[i].pid,proc[i].runtime);
+          }
+          
+          proc[i].runtime = 0;
+      }
+      release(&(proc[i].lock));
+    }
   }
 }
 
diff --git a/kernel/proc.h b/kernel/proc.h
index d021857..ef6816e 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -46,7 +46,7 @@ struct trapframe {
   /*  16 */ uint64 kernel_trap;   // usertrap()
   /*  24 */ uint64 epc;           // saved user program counter
   /*  32 */ uint64 kernel_hartid; // saved kernel tp
-  /*  40 */ uint64 ra;
+  /*  40 */ uint64 ra;            // return address - address to return to after function execution
   /*  48 */ uint64 sp;
   /*  56 */ uint64 gp;
   /*  64 */ uint64 tp;
@@ -91,6 +91,15 @@ struct proc {
   int killed;                  // If non-zero, have been killed
   int xstate;                  // Exit status to be returned to parent's wait
   int pid;                     // Process ID
+  int inQ;                     // Queue number
+  int original_tickets;        // Original number of tickets
+  int current_tickets;         // Current number of tickets
+  int ticksQ0;                 // Number of ticks in queue 0
+  int ticksQ1;                 // Number of ticks in queue 1
+  int runtime;            // Time the process has been running for
+  int times_scheduled;         // Number of times the process was scheduled
+  int waiting_time;            // Time the process has been waiting for before getting scheduled
+
 
   // wait_lock must be held when using this:
   struct proc *parent;         // Parent process
@@ -104,4 +113,19 @@ struct proc {
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int traced_syscall;          // System call number
+
+  struct spinlock memlock;
+  int is_thread;               // if it is thread
+  int mem_id;                  // All threads will have the same physical pages with the mother, hence the same memory ID
 };
+
+// Stores the aggregated information of currently running processes
+struct procInfo {
+  int activeProcess;  // # of processes in RUNNABLE and RUNNING state
+  int totalProcess;   // # of total possible processes
+  int memSize;        // summation of memory of all active processes in bytes
+  int totalMemSize;   // all available physical memory in bytes
+};
+
+extern struct proc proc[NPROC];  // The process table
\ No newline at end of file
diff --git a/kernel/pstat.h b/kernel/pstat.h
new file mode 100644
index 0000000..57d4e63
--- /dev/null
+++ b/kernel/pstat.h
@@ -0,0 +1,22 @@
+#ifndef _PSTAT_H_
+#define _PSTAT_H_
+#include "param.h"
+#include "types.h"
+
+struct pstat {
+int pid[NPROC];
+// the process ID of each process
+int inuse[NPROC]; // whether this slot of the process table is being used (1 or 0)
+int inQ[NPROC]; // which queue the process is currently in
+int waiting_time[NPROC];
+// the time each process has spent waiting before being scheduled
+int running_time[NPROC]; // Number of times the process was scheduled before its time slice was used
+int times_scheduled[NPROC];
+// the total number of times this process was scheduled
+int tickets_original[NPROC]; // the number of tickets each process originally had
+int tickets_current[NPROC]; // the number of tickets each process currently has
+uint queue_ticks[NPROC][2];
+// the total number of ticks each process has spent in each queue
+};
+
+#endif // _PSTAT_H_
\ No newline at end of file
diff --git a/kernel/spinlock.h b/kernel/spinlock.h
index 4392820..f8c92cc 100644
--- a/kernel/spinlock.h
+++ b/kernel/spinlock.h
@@ -6,4 +6,3 @@ struct spinlock {
   char *name;        // Name of lock.
   struct cpu *cpu;   // The cpu holding the lock.
 };
-
diff --git a/kernel/syscall.c b/kernel/syscall.c
index ed65409..f5912e0 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -101,6 +101,19 @@ extern uint64 sys_unlink(void);
 extern uint64 sys_link(void);
 extern uint64 sys_mkdir(void);
 extern uint64 sys_close(void);
+extern uint64 sys_trace(void);
+extern uint64 sys_info(void);
+extern uint64 sys_getLastCommand(void);
+extern uint64 sys_setLastCommand(void);
+extern uint64 sys_setSeed(void);
+extern uint64 sys_getRandomNumbers(void);
+extern uint64 sys_logDecision(void);
+extern uint64 sys_logDecision(void);
+extern uint64 sys_setTickets(void);
+extern uint64 sys_getpinfo(void);
+extern uint64 sys_thread_create(void);
+extern uint64 sys_thread_join(void);
+extern uint64 sys_thread_exit(void);
 
 // An array mapping syscall numbers from syscall.h
 // to the function that handles the system call.
@@ -126,6 +139,53 @@ static uint64 (*syscalls[])(void) = {
 [SYS_link]    sys_link,
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
+[SYS_trace]   sys_trace,
+[SYS_info]    sys_info,
+[SYS_getLastCommand]  sys_getLastCommand,
+[SYS_setLastCommand]  sys_setLastCommand,
+[SYS_setSeed] sys_setSeed,
+[SYS_getRandomNumbers]  sys_getRandomNumbers,
+[SYS_logDecision] sys_logDecision,
+[SYS_setTickets] sys_setTickets,
+[SYS_getpinfo] sys_getpinfo,
+[SYS_thread_create] sys_thread_create,
+[SYS_thread_join] sys_thread_join,
+[SYS_thread_exit] sys_thread_exit,
+};
+
+char* syscall_names[] = {
+[SYS_fork]    "fork",
+[SYS_exit]    "exit",
+[SYS_wait]    "wait",
+[SYS_pipe]    "pipe",
+[SYS_read]    "read",
+[SYS_kill]    "kill",
+[SYS_exec]    "exec",
+[SYS_fstat]   "fstat",
+[SYS_chdir]   "chdir",
+[SYS_dup]     "dup",
+[SYS_getpid]  "getpid",
+[SYS_sbrk]    "sbrk",
+[SYS_sleep]   "sleep",
+[SYS_uptime]  "uptime",
+[SYS_open]    "open",
+[SYS_write]   "write",
+[SYS_mknod]   "mknod",
+[SYS_unlink]  "unlink",
+[SYS_link]    "link",
+[SYS_mkdir]   "mkdir",
+[SYS_close]   "close",
+[SYS_trace]   "trace",
+[SYS_info]    "info",
+[SYS_getLastCommand]  "getLastCommand",
+[SYS_setLastCommand]  "setLastCommand",
+[SYS_setSeed] "setSeed",
+[SYS_getRandomNumbers]  "getRandomNumbers",
+[SYS_setTickets] "setTickets",
+[SYS_getpinfo]  "getpinfo",
+[SYS_thread_create] "thread_create",
+[SYS_thread_join] "thread_join",
+[SYS_thread_exit] "thread_exit",
 };
 
 void
@@ -133,13 +193,206 @@ syscall(void)
 {
   int num;
   struct proc *p = myproc();
-
+  int traced_syscall = p->traced_syscall;
+  // p->traced_syscall = -1;
   num = p->trapframe->a7;
   if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
     // Use num to lookup the system call function for num, call it,
     // and store its return value in p->trapframe->a0
-    p->trapframe->a0 = syscalls[num]();
-  } else {
+
+    if(traced_syscall != num){
+      p->trapframe->a0 = syscalls[num]();
+    }
+    else{
+      printf("pid: %d, syscall: %s, ",p->pid, syscall_names[num]);
+
+      switch(num){
+        case SYS_fork:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_exit:{
+          int status;
+          argint(0, &status);
+          printf("args: (%d), ",status);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_wait:{
+          uint64 addr;
+          argaddr(0, &addr);
+          printf("args: (%lu), ",addr);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_pipe:{
+          uint64 fdarray;
+          argaddr(0, &fdarray);
+          printf("args: (%lu), ",fdarray);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_read:{
+          int fd;
+          uint64 buf;
+          int n;
+          argint(0, &fd);
+          argaddr(1, &buf);
+          argint(2, &n);
+          printf("args: (%d, %p, %d), ",fd, (void*)buf, n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_kill:{
+          int pid;
+          argint(0, &pid);
+          printf("args: (%d), ", pid);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_exec:{
+          char path[MAXPATH];
+          uint64 argv;
+          argstr(0, path, MAXPATH);
+          argaddr(1, &argv);
+          printf("args: (%s, %p), ", path, (void*)argv);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_fstat:{
+          int fd;
+          uint64 statbuf;
+          argint(0, &fd);
+          argaddr(1, &statbuf);
+          printf("args: (%d, %p), ", fd, (void*)statbuf);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_chdir:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_dup:{
+          int oldfd;
+          argint(0, &oldfd);
+          printf("args: (%d), ", oldfd);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_getpid:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_sbrk:{
+          int n;
+          argint(0, &n);
+          printf("args: (%d), ", n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_sleep:{
+          int ticks;
+          argint(0, &ticks);
+          printf("args: (%d), ", ticks);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_uptime:{
+          p->trapframe->a0 = syscalls[num]();
+          printf("args: (), return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_open:{
+          char path[MAXPATH];
+          int flag;
+          argstr(0, path, MAXPATH);
+          argint(1, &flag);
+          printf("args: (%s, %d), ", path, flag);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n",p->trapframe->a0);
+          break;
+        }
+        case SYS_write:{
+          int fd;
+          uint64 buf;
+          int n;
+          argint(0, &fd);
+          argaddr(1, &buf);
+          argint(2, &n);
+          printf("args: (%d, %p, %d), ", fd, (void*)buf, n);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_mknod:{
+          char path[MAXPATH];
+          int major, minor;
+          argstr(0, path, MAXPATH);
+          argint(1, &major);
+          argint(2, &minor);
+          printf("args: (%s, %d, %d), ", path, major, minor);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_unlink:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_link:{
+          char oldpath[MAXPATH];
+          char newpath[MAXPATH];
+          argstr(0, oldpath, MAXPATH);
+          argstr(1, newpath, MAXPATH);
+          printf("args: (%s, %s), ", oldpath, newpath);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_mkdir:{
+          char path[MAXPATH];
+          argstr(0, path, MAXPATH);
+          printf("args: (%s), ", path);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        case SYS_close:{
+          int fd;
+          argint(0, &fd);
+          printf("args: (%d), ", fd);
+          p->trapframe->a0 = syscalls[num]();
+          printf("return: %lu\n", p->trapframe->a0);
+          break;
+        }
+        default:{
+          printf("Not a valid syscall\n");
+          break;
+        }
+      }
+    }
+  }
+  else {
     printf("%d %s: unknown sys call %d\n",
             p->pid, p->name, num);
     p->trapframe->a0 = -1;
diff --git a/kernel/syscall.h b/kernel/syscall.h
index bc5f356..0da7b10 100644
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -20,3 +20,15 @@
 #define SYS_link   19
 #define SYS_mkdir  20
 #define SYS_close  21
+#define SYS_trace  22
+#define SYS_info   23
+#define SYS_getLastCommand 24
+#define SYS_setLastCommand 25
+#define SYS_setSeed 26
+#define SYS_getRandomNumbers 27
+#define SYS_logDecision 28
+#define SYS_setTickets 29
+#define SYS_getpinfo 30
+#define SYS_thread_create 31
+#define SYS_thread_join 32
+#define SYS_thread_exit 33
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 3b4d5bd..561f76d 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -5,6 +5,16 @@
 #include "memlayout.h"
 #include "spinlock.h"
 #include "proc.h"
+#include "pstat.h"
+
+struct spinlock lastCommandLock;
+void initlock(struct spinlock*, char*);
+
+// seed for random number
+int seed = 0;
+
+// used to enable or disable logs; 0->disable, 1->enable
+int print_logs = 0;
 
 uint64
 sys_exit(void)
@@ -91,3 +101,212 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+uint64
+sys_trace(void){
+  int syscall_no;
+  argint(0, &syscall_no);
+  if(syscall_no <= 0){
+    return -1;
+  }
+  // printf("Syscall number: %d\n",syscall_no);
+  struct proc* p = myproc(); //get the process which is calling the syscall
+  p->traced_syscall = syscall_no;
+  return 0;
+}
+
+uint64
+sys_info(void){
+  struct procInfo currentInfo;
+  uint64 addr;
+  argaddr(0, &addr);
+
+  currentInfo.activeProcess = 0;
+  currentInfo.totalProcess = NPROC;
+  currentInfo.memSize = 0;
+
+  for(int i=0;i<NPROC;i++){
+    acquire(&(proc[i].lock));
+    if(proc[i].state == RUNNABLE || proc[i].state == RUNNING || proc[i].state == SLEEPING){
+      currentInfo.activeProcess++;
+      currentInfo.memSize += proc[i].sz;
+    }
+    release(&(proc[i].lock));
+  }
+  currentInfo.totalMemSize = PHYSTOP - KERNBASE;
+
+  return copyout(myproc()->pagetable, addr, (char *)&currentInfo, sizeof(struct procInfo));
+}
+
+static char lastCommands[100][100];
+static int nCommands = 0;
+int getSize(char* str){
+  int i = 0;
+  while(str[i] != '\0'){
+    i++;
+  }
+  return i+1;
+}
+
+void my_strcpy(char* src, char* dst){
+  int i = 0;
+  while(dst[i] != '\0'){
+    dst[i] = '\0';
+    i++;
+  }
+
+  i = 0;
+  while(src[i] != '\0'){
+    dst[i] = src[i];
+    i++;
+  }
+  dst[i] = '\0';
+}
+
+uint64
+sys_getLastCommand(void){
+  initlock(&lastCommandLock, "lastCommandLock");
+  uint64 addr;
+  acquire(&lastCommandLock);
+  argaddr(0, &addr);
+  int n;
+  argint(1, &n);
+  if(n <= 0 || n > nCommands){
+    release(&lastCommandLock);
+    return -1;
+  }
+  struct proc* p = myproc();
+  if(lastCommands[nCommands-n][0] != '\0'){
+    int success = copyout(p->pagetable, addr, lastCommands[nCommands-n], getSize(lastCommands[nCommands-n]));
+    release(&lastCommandLock);
+    return success;
+  }
+  release(&lastCommandLock);
+  return -1;
+}
+
+uint64
+sys_setLastCommand(void){
+  char command[100];
+  uint64 addr;
+  acquire(&lastCommandLock);
+  argaddr(0, &addr);
+  struct proc* p = myproc();
+  if(copyin(p->pagetable, command, addr, 100) < 0){
+    release(&lastCommandLock);
+    return -1;
+  }
+  my_strcpy(command, lastCommands[nCommands++]);
+  release(&lastCommandLock);
+  return 0;
+}
+
+
+uint64
+sys_setSeed(void){
+  int n;
+  argint(0, &n);
+
+  if(n < 0){
+    return -1;
+  }
+  seed = n;
+  return seed;
+}
+
+uint64
+sys_getRandomNumbers(void){
+  int n;
+  uint64 arr_addr;
+  argint(0, &n);
+  argaddr(1, &arr_addr);
+
+  int array[n];
+  for(int i=0;i<n;i++){
+    array[i] = ++seed;
+  }
+
+  return copyout(myproc()->pagetable, arr_addr, (char*)array, n*sizeof(int));
+}
+
+uint64
+sys_logDecision(void){
+  int decision;
+  argint(0, &decision);
+  if(decision == 0 || decision == 1){
+    print_logs = decision;
+    return print_logs;
+  }
+  return -1;
+}
+
+uint64
+sys_setTickets(void){
+  int nTickets;
+  argint(0, &nTickets);
+  struct proc* p = myproc();
+  acquire(&p->lock);
+  // printf("%d ",nTickets);
+  if(nTickets < 1){
+    p->original_tickets = DEFAULT_TICKETS;
+    p->current_tickets = DEFAULT_TICKETS;
+    // release(&p->lock);
+    // return -1;
+  }
+  else{
+    p->original_tickets = nTickets; 
+    p->current_tickets = nTickets;
+    // release(&p->lock);
+    // return 0;
+  }
+  release(&p->lock);
+  return p->original_tickets;
+}
+
+uint64
+sys_getpinfo(void){
+  uint64 addr;
+  argaddr(0, &addr);
+  struct pstat stat;
+  // work left
+  for(int i=0;i<NPROC;i++){
+    stat.pid[i] = proc[i].pid;
+    stat.inuse[i] = (proc[i].state == RUNNABLE || proc[i].state == RUNNING);
+    stat.inQ[i] = proc[i].inQ;
+    stat.waiting_time[i] = proc[i].waiting_time;
+    stat.running_time[i] = proc[i].runtime;
+    stat.times_scheduled[i] = proc[i].times_scheduled;
+    stat.tickets_original[i] = proc[i].original_tickets;
+    stat.tickets_current[i] = proc[i].current_tickets;
+    stat.queue_ticks[i][0] = proc[i].ticksQ0;
+    stat.queue_ticks[i][1] = proc[i].ticksQ1;
+  }
+
+  return copyout(myproc()->pagetable, addr, (char*)&stat, sizeof(struct pstat));
+}
+
+uint64
+sys_thread_create(void){
+  uint64 func_addr;
+  uint64 arg_addr;
+  uint64 stack_addr;
+  argaddr(0, &func_addr);
+  argaddr(1, &arg_addr);
+  argaddr(2, &stack_addr);
+  return thread_create(func_addr,arg_addr,stack_addr);
+}
+
+uint64
+sys_thread_join(void){
+  int thread_id;
+  argint(0, &thread_id);
+  return thread_join(thread_id);
+}
+
+
+uint64
+sys_thread_exit(void){
+  exit(0);
+  return 0;
+}
+
diff --git a/kernel/vm.c b/kernel/vm.c
index 5c31e87..1af5825 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -272,6 +272,21 @@ uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
 
   return newsz;
 }
+// After deallocating memory in a process/thread
+// Update the pagetable of the all the process/threads with the same memory ID
+uint64
+uvmdealloc_mirror(pagetable_t pagetable, uint64 oldsz, uint64 newsz)
+{
+  if(newsz >= oldsz)
+    return oldsz;
+
+  if(PGROUNDUP(newsz) < PGROUNDUP(oldsz)){
+    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
+    uvmunmap(pagetable, PGROUNDUP(newsz), npages, 0);
+  }
+
+  return newsz;
+}
 
 // Recursively free page-table pages.
 // All leaf mappings must already have been removed.
@@ -302,6 +317,13 @@ uvmfree(pagetable_t pagetable, uint64 sz)
     uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 1);
   freewalk(pagetable);
 }
+void
+uvmfree_thread(pagetable_t pagetable, uint64 sz)
+{
+  if(sz > 0)
+    uvmunmap(pagetable, 0, PGROUNDUP(sz)/PGSIZE, 0);
+  freewalk(pagetable);
+}
 
 // Given a parent process's page table, copy
 // its memory into a child's page table.
@@ -339,6 +361,64 @@ uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
   return -1;
 }
 
+// Modified version of uvmcopy that does not allocate new memory
+// Used for threads instead of processes
+int
+uvmmirror(pagetable_t old, pagetable_t new, uint64 sz)
+{
+  pte_t *pte;
+  uint64 pa, i;
+  uint flags;
+
+  for(i = 0; i < sz; i += PGSIZE){
+    if((pte = walk(old, i, 0)) == 0)
+      panic("uvmcopy: pte should exist");
+    if((*pte & PTE_V) == 0)
+      panic("uvmcopy: page not present");
+    pa = PTE2PA(*pte);
+    flags = PTE_FLAGS(*pte);
+    if(mappages(new, i, PGSIZE, pa, flags) != 0){
+      goto err;
+    }
+  }
+  return 0;
+
+ err:
+  uvmunmap(new, 0, i / PGSIZE, 1);
+  return -1;
+}
+// For dynamic memory allocation 
+// Pagetables of all the processes(1 process, rest are threads) with the same memory ID 
+// shall be updated with the new memory
+int
+uvmmirror_partial(pagetable_t old, pagetable_t new, uint64 oldsz, uint64 newsz)
+{
+  pte_t *pte;
+  uint64 pa, i;
+  uint flags;
+
+  // Starting from the closest multiple of PGSIZE from oldsz
+  oldsz = PGROUNDUP(oldsz);
+  // Instead of mirroring the entire memory, mirror only the new memory
+  for(i = oldsz; i < newsz; i += PGSIZE){
+    if((pte = walk(old, i, 0)) == 0)
+      panic("uvmcopy: pte should exist");
+    if((*pte & PTE_V) == 0)
+      panic("uvmcopy: page not present");
+    pa = PTE2PA(*pte);
+    flags = PTE_FLAGS(*pte);
+    if(mappages(new, i, PGSIZE, pa, flags) != 0){
+      goto err;
+    }
+  }
+  return 0;
+
+ err:
+  // Unmap only the newly allocated memory
+  uvmunmap(new, oldsz, i / PGSIZE, 1);
+  return -1;
+}
+
 // mark a PTE invalid for user access.
 // used by exec for the user stack guard page.
 void
diff --git a/user/dummyproc.c b/user/dummyproc.c
new file mode 100644
index 0000000..4c290ce
--- /dev/null
+++ b/user/dummyproc.c
@@ -0,0 +1,43 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc,char* argv[]){
+    if(argc < 3){
+        printf("Invalid number of arguments for dummyproc\n");
+        exit(1);
+    }
+
+    int nTickets = atoi(argv[1]);
+    int loopCount = atoi(argv[2]);
+
+
+    int decision = setTickets(nTickets);
+    if(decision == -1){
+        printf("Invalid number of tickets provided.\nDefault number of tickets has been assigned.\n");
+    }
+    else{
+        printf("Set number of tickets to %d\n",decision);
+    }
+    
+    int pid;
+    for(int i=0;i<4;i++){
+        pid = fork();
+        if(pid == 0) break;
+    }
+    if(pid == 0){
+        //Child process
+        for(int i=0;i<loopCount;i++){
+            if(i%100000000 == 0) sleep(1);
+        }
+    }
+    else if(pid > 0){
+        //Parent process
+        for(int i=0;i<loopCount;i++);
+    }
+    else{
+        printf("Error: fork failed\n");
+        exit(1);
+    }
+
+    return 0;
+}
\ No newline at end of file
diff --git a/user/load.c b/user/load.c
new file mode 100644
index 0000000..1939203
--- /dev/null
+++ b/user/load.c
@@ -0,0 +1,75 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int getFractionPart(int dividend, int divisor){
+    int modified_quotient = (dividend*100)/divisor;
+    int fraction = modified_quotient % 100;
+    return fraction;
+}
+
+int main(int argc, char** argv){
+    if(argc != 3){
+        printf("Wrong number of arguments!\n");
+        printf("Usage: load <child_count> <allocation_amount>\n");
+        exit(1);
+    }
+
+    int childCount = atoi(argv[1]);
+    int allocationAmount = atoi(argv[2]);
+
+    printf("Child count: %d\n", childCount);
+    printf("Allocation amount: %d\n", allocationAmount);
+
+    printf("Parent going to sleep.\n");
+    sleep(10);
+
+    for(int i=0;i<childCount;i++){
+        int pid = fork();
+        //pid == 0 means child process
+        if(pid == 0){
+            sleep(i+1); // Child sleeps for a while
+            printf("Child is created.\n");
+            malloc(allocationAmount);
+            printf("Child allocated memory %d byte.\n", allocationAmount);
+            printf("Child is going to sleep.\n");
+            sleep(100); // Child sleeps for a long time
+            exit(0);
+        }
+    }
+
+    sleep(100);
+
+    printf("Parent wake up.\n");
+    struct procInfo currentInfo;
+
+    info(&currentInfo);
+    printf("Current system information:\n");
+    printf("Processes: %d/%d\n", currentInfo.activeProcess, currentInfo.totalProcess);
+    int memSize = currentInfo.memSize;
+    int totalMemSize = currentInfo.totalMemSize;
+    int memSize_whole = memSize/(1024*1024);
+    int memSize_fraction = getFractionPart(memSize, 1024*1024);
+    int totalMemSize_whole = totalMemSize/(1024*1024);
+    int totalMemSize_fraction = getFractionPart(totalMemSize, 1024*1024);
+    if(memSize_fraction == 0){
+        printf("RAM: %d/", memSize_whole);
+    }
+    else if(memSize_fraction < 10){
+        printf("RAM: %d.0%d/", memSize_whole, memSize_fraction);
+    }
+    else{
+        printf("RAM: %d.%d/", memSize_whole, memSize_fraction);
+    }
+
+    if(totalMemSize_fraction == 0){
+        printf("%d", totalMemSize_whole);
+    }
+    else if(totalMemSize_fraction < 10){
+        printf("%d.0%d", totalMemSize_whole, totalMemSize_fraction);
+    }
+    else{
+        printf("%d.%d", totalMemSize_whole, totalMemSize_fraction);
+    }
+    printf(" (in MB)\n");
+    return 0;
+}
\ No newline at end of file
diff --git a/user/logs.c b/user/logs.c
new file mode 100644
index 0000000..e0cd724
--- /dev/null
+++ b/user/logs.c
@@ -0,0 +1,24 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char* argv[]){
+    if(argc < 2){
+        printf("Decision not provided\n");
+        exit(1);
+    }
+    
+    int decision = atoi(argv[1]);
+
+    if(logDecision(decision) == 0){
+        printf("Print logs disabled\n");        
+    }
+    else if(logDecision(decision) == 1){
+        printf("Print logs enabled\n");
+    }
+    else{
+        printf("Error in changing log decision\n");
+        exit(1);
+    }
+    // printf("Hello from logs\n");
+    return 0;
+}
\ No newline at end of file
diff --git a/user/next.c b/user/next.c
new file mode 100644
index 0000000..d574999
--- /dev/null
+++ b/user/next.c
@@ -0,0 +1,42 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char* argv[]){
+    int n;
+    if(argc == 1){
+        n = argc;
+    }
+    else if(argc == 2){
+        n = atoi(argv[1]);
+    }
+    else{
+        printf("Invalid number of arguments for next\n");
+        exit(1);
+    }
+
+    int randomNumbers[n];
+
+    int response = getRandomNumbers(n, randomNumbers);
+
+    if(response == -1){
+        printf("Random number generation failed\n");
+        exit(1);
+    }
+    else{
+        if(n == 1){
+            printf("Next random number is: %d\n", randomNumbers[0]);
+        }
+        else{
+            printf("Next random numbers are: [ ");
+            for(int i=0;i<n;i++){
+                if(i == n-1){
+                    printf("%d ]\n", randomNumbers[i]);
+                }
+                else{
+                    printf("%d, ", randomNumbers[i]);
+                }
+            }
+        }
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/user/seed.c b/user/seed.c
new file mode 100644
index 0000000..64fa6a2
--- /dev/null
+++ b/user/seed.c
@@ -0,0 +1,22 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char* argv[]){
+    if(argc != 2){
+        printf("Invalid number of arguments for seed\n");
+        exit(1);
+    }
+
+    int seed = atoi(argv[1]);
+
+    int response = setSeed(seed);
+
+    if(response == -1){
+        printf("Seed failed\n");
+        exit(1);
+    }
+    else{
+        printf("Seed has been set to %d\n", response);
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/user/sh.c b/user/sh.c
index 836ebcb..1df5dcc 100644
--- a/user/sh.c
+++ b/user/sh.c
@@ -159,12 +159,50 @@ main(void)
   // Read and run input commands.
   while(getcmd(buf, sizeof(buf)) >= 0){
     if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){
+      //storing the current command
+      if(setLastCommand(buf) < 0){
+        fprintf(2, "setLastCommand failed\n");
+        continue;
+      }
       // Chdir must be called by the parent, not the child.
       buf[strlen(buf)-1] = 0;  // chop \n
       if(chdir(buf+3) < 0)
         fprintf(2, "cannot cd %s\n", buf+3);
+
+      continue;
+    }
+    if(buf[0] == '!' && buf[1] == '!'){
+      int success;
+      if(buf[2] == '\n'){
+        success = getLastCommand(buf,1);
+      }
+      else{
+        int n;
+        if(buf[2] == ' '){
+          if(buf[3] == '\n' || buf[3] == ' '){
+            n = 1;
+          }
+          else{
+            n = buf[3] - 48;
+          }
+        }
+        else{
+          n = buf[2] - 48;
+        }
+        success = getLastCommand(buf,n);
+      }
+      if(success < 0){
+        fprintf(2,"getLastCommand failed\n");
+        continue;
+      }
+      printf("%s",buf);
+    }
+
+    if(setLastCommand(buf) < 0){
+      fprintf(2, "setLastCommand failed\n");
       continue;
     }
+
     if(fork1() == 0)
       runcmd(parsecmd(buf));
     wait(0);
diff --git a/user/testprocinfo.c b/user/testprocinfo.c
new file mode 100644
index 0000000..309fadb
--- /dev/null
+++ b/user/testprocinfo.c
@@ -0,0 +1,22 @@
+#include "kernel/types.h"
+#include "kernel/param.h"
+#include "user/user.h"
+
+int main(int argc,char* argv[]){
+    // printf("Hello world from testprocinfo\n");
+
+    struct pstat p;
+    int decision = getpinfo(&p);
+    if(decision == -1){
+        printf("Error in getting process information\n");
+        exit(1);
+    }
+
+    printf("PID | In use | In Q | Waiting Time | Running Time | # Times Scheduled | Original Tickets | Current Tickets | q0 | q1\n");
+    for(int i=0;i<NPROC;i++){
+        if(p.pid[i] == 0) continue;
+        printf("%d       %d        %d           %d              %d              %d                  %d              %d              %d    %d\n"\
+        ,p.pid[i],p.inuse[i],p.inQ[i],p.waiting_time[i],p.running_time[i],p.times_scheduled[i],p.tickets_original[i],p.tickets_current[i],p.queue_ticks[i][0],p.queue_ticks[i][1]);
+    }
+    return 0;
+}
\ No newline at end of file
diff --git a/user/threads.c b/user/threads.c
new file mode 100644
index 0000000..31ab7a0
--- /dev/null
+++ b/user/threads.c
@@ -0,0 +1,153 @@
+#include "kernel/types.h"
+#include "kernel/stat.h"
+#include "user/user.h"
+
+struct balance {
+    char name[32];
+    int amount;
+};
+
+struct thread_spinlock {
+    uint locked;
+};
+
+
+void thread_spin_init(struct thread_spinlock *lk){
+    lk->locked = 0;
+}
+
+void thread_spin_lock(struct thread_spinlock *lk)
+{
+  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
+  //   a5 = 1
+  //   s1 = &lk->locked
+  //   amoswap.w.aq a5, a5, (s1)
+  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
+    ;
+
+  // Tell the C compiler and the processor to not move loads or stores
+  // past this point, to ensure that the critical section's memory
+  // references happen strictly after the lock is acquired.
+  // On RISC-V, this emits a fence instruction.
+  __sync_synchronize();
+}
+
+void thread_spin_unlock(struct thread_spinlock *lk){
+    if(!lk->locked) {
+        printf("Error: thread_spin_unlock: Cannot unlock an unlocked lock\n");
+        exit(1);
+    }
+    __sync_synchronize();
+    // Release the lock, equivalent to lk->locked = 0.
+    // This code doesn't use a C assignment, since the C standard
+    // implies that an assignment might be implemented with
+    // multiple store instructions.
+    // On RISC-V, sync_lock_release turns into an atomic swap:
+    //   s1 = &lk->locked
+    //   amoswap.w zero, zero, (s1)
+  __sync_lock_release(&lk->locked);
+}
+
+struct thread_mutex {
+    uint locked;
+};
+
+void thread_mutex_init(struct thread_mutex *m){
+    m->locked = 0;
+}
+
+void thread_mutex_lock(struct thread_mutex *m)
+{
+  while(__sync_lock_test_and_set(&m->locked, 1) != 0){
+    sleep(1);
+  }
+  __sync_synchronize();
+}
+
+void thread_mutex_unlock(struct thread_mutex *m){
+    // printf("Entered mutex unlock\n");
+    if(!m->locked) {
+        printf("Error: thread_mutex_unlock: Cannot unlock an unlocked lock\n");
+        exit(1);
+    }
+    // printf("Mutex is locked. Unlocking...\n");
+    __sync_synchronize();
+    // printf("Done with synchornizing\n");
+    __sync_lock_release(&m->locked);
+    // printf("Successfully unlocked\n");
+}
+
+volatile int total_balance = 0;
+
+volatile unsigned int delay (unsigned int d) {
+   unsigned int i; 
+   for (i = 0; i < d; i++) {
+       __asm volatile( "nop" ::: );
+   }
+
+   return i;   
+}
+struct thread_spinlock lock;
+struct thread_mutex mlock;
+
+void init_locks(){
+    thread_spin_init(&lock);
+    thread_mutex_init(&mlock);
+}
+void do_work(void *arg){
+    int i; 
+    int old;
+   
+    struct balance *b = (struct balance*) arg; 
+    thread_spin_lock(&lock);
+    // thread_mutex_lock(&mlock);
+    printf( "Starting do_work: s:%s\n", b->name);
+    thread_spin_unlock(&lock);
+    // thread_mutex_unlock(&mlock);
+
+    for (i = 0; i < b->amount; i++) { 
+        // lock and mlock will be implemented by you.
+        // thread_spin_lock(&lock);
+        thread_mutex_lock(&mlock);
+        old = total_balance;
+         delay(100000);
+	    // if(old != total_balance)  printf("we will miss an update. old: %d total_balance: %d\n", old, total_balance);
+        total_balance = old + 1;
+        // thread_spin_unlock(&lock);
+        thread_mutex_unlock(&mlock);
+
+    }
+    thread_spin_lock(&lock);
+    // thread_mutex_lock(&mlock);
+    printf( "Done s:%s\n", b->name);
+    thread_spin_unlock(&lock);
+    // thread_mutex_unlock(&mlock);
+
+    thread_exit();
+    return;
+}
+
+int main(int argc, char *argv[]){
+  
+  init_locks(); 
+
+  struct balance b1 = {"b1", 3200};
+  struct balance b2 = {"b2", 2800};
+ 
+  void *s1, *s2;
+  int thread1, thread2, r1, r2;
+
+  s1 = malloc(4096); // 4096 is the PGSIZE defined in kernel/riscv.h
+  s2 = malloc(4096);
+
+  thread1 = thread_create(do_work, (void*)&b1, s1);
+  thread2 = thread_create(do_work, (void*)&b2, s2); 
+
+  r1 = thread_join(thread1);
+  r2 = thread_join(thread2);
+  
+  printf("Threads finished: (%d):%d, (%d):%d, shared balance:%d\n", 
+      thread1, r1, thread2, r2, total_balance);
+
+  exit(0);
+}
\ No newline at end of file
diff --git a/user/trace.c b/user/trace.c
new file mode 100644
index 0000000..a515314
--- /dev/null
+++ b/user/trace.c
@@ -0,0 +1,21 @@
+#include "kernel/types.h"
+#include "user/user.h"
+
+int main(int argc, char** argv){
+    int syscall_no;
+    if(argc >= 2){
+        syscall_no = atoi(argv[1]);
+    }
+    else{
+        printf("Please provide a syscall number\n");
+        exit(1);
+    }
+    int valid_syscall = trace(syscall_no);
+    if(valid_syscall == -1){
+        printf("Invalid syscall number\n");
+        exit(1);
+    }
+    // argv+2 reprsents the array from the 3rd to the last element of the argv array
+    exec(argv[2], argv+2);
+    return 0;
+}
\ No newline at end of file
diff --git a/user/user.h b/user/user.h
index 04013ca..d799be6 100644
--- a/user/user.h
+++ b/user/user.h
@@ -1,5 +1,13 @@
-struct stat;
+#include "kernel/pstat.h"
 
+struct stat;
+// Stores the aggregated information of currently running processes
+struct procInfo{
+    int activeProcess;  // # of processes in RUNNABLE and RUNNING state
+    int totalProcess;   // # of total possible processes
+    int memSize;        // summation of memory of all active processes in bytes
+    int totalMemSize;   // all available physical memory in bytes
+};
 // system calls
 int fork(void);
 int exit(int) __attribute__((noreturn));
@@ -22,6 +30,18 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int trace(int);
+int info(struct procInfo*);
+int getLastCommand(char*,int);
+int setLastCommand(char*);
+int setSeed(int);
+int getRandomNumbers(int, int*);
+int logDecision(int);
+int setTickets(int);
+int getpinfo(struct pstat*);
+int thread_create(void (*fcn)(void*),void *arg,void *stack);
+int thread_join(int);
+int thread_exit(void);
 
 // ulib.c
 int stat(const char*, struct stat*);
diff --git a/user/usys.pl b/user/usys.pl
index 01e426e..ec6b878 100755
--- a/user/usys.pl
+++ b/user/usys.pl
@@ -36,3 +36,15 @@ entry("getpid");
 entry("sbrk");
 entry("sleep");
 entry("uptime");
+entry("trace");
+entry("info");
+entry("getLastCommand");
+entry("setLastCommand");
+entry("setSeed");
+entry("getRandomNumbers");
+entry("logDecision");
+entry("setTickets");
+entry("getpinfo");
+entry("thread_create");
+entry("thread_join");
+entry("thread_exit");
